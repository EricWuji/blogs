## D

根据题目给出的构造方式，$S_n'$ 的长度会达到 $2^n$ 数量级，没法求出 $S_n'$，所以考虑递推。

设 $dp_{i,l,r}$ 为 $S_i'$ 里 $T$ 的 $[l,r]$ 区间以子序列的方式出现了多少次，可以写出转移方程：$dp_{i,l,r} = \sum dp_{i-1,l,k}\cdot dp_{i-1,k+1,r} + [a_i=T_k]\cdot \sum dp_{i-1,l,k-1}\cdot dp_{i-1,k+1,r}$，其中 $k\in [l,r]$。

第一个大 $\sum$ 计算不考虑中间的 $a_i$ 时，前一个 $S_{i-1}'$ 里左半段 $[l,k]$ 出现的次数乘上后一个 $S_{i-1}'$ 里右半段 $[k+1,r]$ 出现的次数——当然，需要注意加上左半段或右半段为空的边界情况；第二个大 $\sum$ 计算如果中间 $a_i=T_k$ 时，左半段和右半段出现次数之积，同样要注意左右半段为空的情况。具体实现上，可以直接 `dp[i][l][l-1] = dp[i][r+1][r] = 1` 处理。

```cpp
rep(i, 1, n) rep(l, 1, m) // n,m分别为a,t长度
    rep(r, l, m) { // t的[l,r]在s_i出现多少次
        dp[i - 1][l][l - 1] = 1; // 将不合法区间设为1，便于计算
        dp[i - 1][r + 1][r] = 1;
        int64_t& res = dp[i][l][r] = dp[i - 1][l][r];  // 循环取不到“左半段为空”情况，这里补上
        rep(k, l, r) {
            res += dp[i - 1][l][k] * dp[i - 1][k + 1][r]; //略去取模操作
            if (s[i] == t[k]) res += dp[i - 1][l][k - 1] * dp[i - 1][k + 1][r]; }}
cout << dp[n][1][m];
```

