可持久化数据结构对空间有要求，其优点是**充分利用了已经“记住”的信息**。

## 一、可持久化数组

> [P3919 【模板】可持久化线段树 1（可持久化数组）](https://www.luogu.com.cn/problem/P3919)
> 
> 你需要维护这样的一个长度为 $N$ 的数组，支持如下几种操作：1) 在某个历史版本上修改某一个位置上的值; 2) 访问某个历史版本上的某一位置的值。
> 
> 此外，每进行一次操作（对于操作2，即为**生成一个完全一样的版本**，不作任何改动），就会生成一个新的版本。版本编号即为当前操作的编号（从1开始编号，版本0表示初始状态数组）。
”

“一个完全一样的版本”，首先想到的是——全部记下来，也就是每一次更新，都把数组做一次 `memcpy()` 操作，空间复杂度$O(nm)$，MLE。

但并不用全复制一遍——一个显然的方法是，只把改变的点复制出来，或者说，**每次更新时，只把那些要改变的的节点创建成一个新的，保留原来的作为历史版本。** 这样，空间复杂度就只有 $O(n*4+q*log_n)$ 了。

如下图，看起来像一棵正常的线段树上寄生了若干个不完整的线段树。

![示意图](https://cdn.luogu.com.cn/upload/pic/46147.png)

## 二、静态区间第k小

[P3834 【模板】可持久化线段树 2（主席树）](https://www.luogu.com.cn/problem/P3834)

我们建立一棵主席树，他维护的是“值域”，即所谓**权值线段树**。每读入一个数，就做一次 update 以加入，留下了 $n$ 个版本。线段树 $i$ 每个点的 $t[p].val$ 值为 $[1,i]$ 范围内，$[t[p].l,t[p].r]$ 内有多少个不同的数字。按照前缀和方式计算出 $x$ 与 $mid$ 相比较，并确定向左还是右递归。

下面是代码。要特别注意，对于右子树的 update 操作，第二个参数传的是 $k-x$ 。这与 Splay 中求 $kth$ 的方法十分相近。

## 三、可持久化并查集

模板题是[P3402 可持久化并查集](https://www.luogu.com.cn/problem/P3402)。

考虑用主席树维护每个并查集里每个节点的父亲关系。平时写的一行并查集 `inline int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}` 运用了路径压缩算法，大大减小了时间消耗。但是，路径压缩的并查集不利于可持久化。为了方便模拟，**可持久化的并查集不路径压缩。**

在寻找父亲时，我们要做的就是在主席树上找到点 $u=find(a)$ 和 $v=find(b)$ ，分别向上跑直到 $root$ ，然后像普通版一样把前者的父亲设为后者。

不路径压缩，并查集如果退化为一条长链，时间复杂度会崩溃。为了解决这一问题，我们采取**启发式合并**，即把最大深度最小的连通块往最大深度大的上面合并。[证明](https://www.zhihu.com/question/29663921)。